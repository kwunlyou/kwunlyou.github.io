---
layout: post
title: Simulate real cameras in Blender
categories:
- Graphics
tags:
- blender
- computer vision
- matlab
- python
---
<p>Recently I need to simulate real cameras, e.g. render models in different views and get projection matrices of different views. Projection matrices can not be got directly, first we have to get all the parameters of cameras.</p>

<p>I use pinhole camera model here. Because there are many different conventions which make confusion.  All the convention here follows the course <a href="ftp://ftp.esat.kuleuven.ac.be/psi/visics/vergauwe/course.pdf" target="_blank"> 3D acquisition</a> (page 23-26). In addition, I use Blender 2.61 with Python API. If you are fresh in Blender, it is better to spend about 1 hour to learn something about it, here is a very good <a href="http://cgcookie.com/blender/get-started-with-blender/" target="_blank">tutorial</a>.</p>

<p>You can download my example <a href="https://docs.google.com/file/d/0B4WuPv10qopdcldLcl9TLS1SWU8wdTIxOTZBQ2tsQQ/edit">here</a> (<span style="color: #ff0000;">Sorry, this link is dead now. But it doesn't matter. All the source code can be found in the following paragraphs.</span>). It includes all the files I talk about  following.</p>
<ol>
<li>New a blender projection.  Add a mesh, I choose the cute monkey  in this example. Then add cameras. Materials, lighting ... Blablabla... Actually these are not crucial for the following work. We just need models and cameras.</li>
<li>Open the Python console in Blender.</li>
<li>Render all the views. Copy the following script in console and run. Blender will render all the views and save images in YOURPATH you defined.
<pre class="brush: python; gutter: true; first-line: 1; html-script: true">[codesyntax lang="python"]</pre>
<pre>import bpy
import string
scn = bpy.data.scenes['Scene']
scn.render.image_settings.file_format = 'JPEG';
scn.render.image_settings.color_depth = '24';
scn.render.image_settings.compression = 100;

path = ‘YOURPATH'
counter = 0;

for ob in bpy.data.objects:
    if ob.type == 'CAMERA':
        scn.camera = ob
        name = '{:08d}'.format(counter)
        scn.render.filepath = path + name
        bpy.ops.render.render(write_still=True)
        counter = counter + 1</pre>
<pre class="brush: python; gutter: true; first-line: 1; html-script: true">[/codesyntax]</pre>
</li>
<li>Output camera parameters. Open text editor in Blender and copy the following script and paste. In order to avoid TAB and space problem, press Format - Convert Whitespace - To Spaces. ALT+P to run the script. Blender will save all the camera parameters in txt files.<br />
[codesyntax lang="python"]</p>
<pre>import bpy
import string
scn = bpy.data.scenes['Scene']
w = scn.render.resolution_x
h = scn.render.resolution_y
per = scn.render.resolution_percentage
w = w*per/100;
h = h*per/100;

path = 'YOURPATH'
counter = 0

for ob in bpy.data.objects:
    if ob.type == 'CAMERA':
        name = ob.name
        filename = path + 'cam_' + '{:08d}'.format(counter) + '.txt'

        file = open(filename, 'w')

        # get camera obj and setting
        cam1 = bpy.data.cameras[name]
        RT = ob.matrix_world.inverted() 

        # lens length
        file.write("%f \n" % cam1.lens)

        # sensor
        file.write("%f %f\n" % (cam1.sensor_width, cam1.sensor_height))

        # size
        file.write("%f %f\n" % (w, h))

        # rotation and translation
        RT.transpose();
        file.write("%16.16f %16.16f %16.16f %16.16f\n" % (RT[0][0], RT[0][1], RT[0][2], RT[0][3]))
        file.write("%16.16f %16.16f %16.16f %16.16f\n" % (RT[1][0], RT[1][1], RT[1][2], RT[1][3]))
        file.write("%16.16f %16.16f %16.16f %16.16f\n" % (RT[2][0], RT[2][1], RT[2][2], RT[2][3]))

        # close
        file.close
        counter = counter + 1</pre>
<p>[/codesyntax]</li>
<li>Compute projection matrices. I use  MATLAB scripts to compute them. The function is read_and_convert. Up to now, we have already computed the projection matrix, and say we save them in matrix proj_mat.<br />
[codesyntax lang="matlab"]</p>
<pre>function proj_mat = read_and_convert(n)
% read camera parameters and convert into 3 by 4 matrix
% NOTE:
% n --- number of cameras
% OUTPUT is "proj_mat"

% projection matrix (FINAL RESULTS)
proj_mat = zeros(3, 4, n);

for ii=1:n
    name = ii-1;
    name = sprintf('%08d', name);
    name = ['cam_' name '.txt'];
    fid = fopen(name, 'r');

    % lens
    lens = fscanf(fid, '%f\n', 1);    	

    % sensor
    sensor_w = fscanf(fid, '%f', 1);
    sensor_h = fscanf(fid, '%f\n', 1);    

    % size
    size_w = fscanf(fid, '%f', 1);
    size_h = fscanf(fid, '%f\n', 1);

    % pixel to unit
    sensor_w = sensor_w / size_w;
    sensor_h = sensor_h / size_h;

    % shift
    shift_w = size_w / 2 * sensor_w;
    shift_h = size_h / 2* sensor_h;

    % RT
    RT = fscanf(fid, '%f', [4, 3]);
    RT = RT';

    % compute K
    K = [lens 0 shift_w; ...
        0 lens shift_h; ...
        0 0 1];

    K(1, : ) = K(1, : )/sensor_w;
    K(2, : ) = K(2, : )/sensor_h;

    % change global coordinates
    trans_mat = [1 0 0; 0 -1 0; 0 0 -1];

    % compute projection matrix
    proj_mat(: , : , ii ) = K*trans_mat*RT;

    fclose(fid);
end

end</pre>
<p>[/codesyntax]</li>
<li>Output 3D model. I only test export OBJ format. It works well. However, please note that you have to choose  Z-Up and Y-Forward. Otherwise the coordinate frame is wrong.</li>
<li>Convert OBJ to OFF file. Because it is easy to write a OFF parser. It is better to use <a href="http://meshlab.sourceforge.net/" target="_blank">MeshLab </a>to convert OBJ to OFF.</li>
<li>Using script check.m to check the results. NOTE: This script also uses function load_mesh_off.</li>
</ol>
<p>If you find something wrong in the post, please let me know, thanks! :)</p>
